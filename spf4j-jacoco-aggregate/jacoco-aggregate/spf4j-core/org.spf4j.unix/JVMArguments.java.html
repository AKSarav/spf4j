<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>JVMArguments.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">spf4j-jacoco-aggregate</a> &gt; <a href="../index.html" class="el_bundle">spf4j-core</a> &gt; <a href="index.source.html" class="el_package">org.spf4j.unix</a> &gt; <span class="el_source">JVMArguments.java</span></div><h1>JVMArguments.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2001-2017, Zoltan Farkas All Rights Reserved.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * Additionally licensed with:
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.spf4j.unix;

import com.google.common.io.Files;
import com.sun.jna.StringArray;
import com.sun.jna.Memory;
import com.sun.jna.Native;
import static com.sun.jna.Pointer.NULL;
import com.sun.jna.ptr.IntByReference;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

import java.io.IOException;
import java.io.File;
import java.io.ByteArrayOutputStream;
import java.io.RandomAccessFile;
import java.io.DataInputStream;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Objects;
import java.util.function.Function;
import javax.annotation.Nullable;
import org.spf4j.base.Runtime;
import org.spf4j.unix.CLibrary.FILE;

/**
 * List of arguments for Java VM and application. based on class from akuma lib (http://akuma.kohsuke.org).
 */
@SuppressFBWarnings(&quot;DM_DEFAULT_ENCODING&quot;)
// default char encoding is used on purpose.
public final class JVMArguments {

  private final List&lt;String&gt; arguments;

<span class="fc" id="L68">  public JVMArguments(final int size) {</span>
<span class="fc" id="L69">    arguments = new ArrayList&lt;&gt;(size);</span>
<span class="fc" id="L70">  }</span>

<span class="fc" id="L72">  public JVMArguments(final Collection&lt;? extends String&gt; c) {</span>
<span class="fc" id="L73">    arguments = new ArrayList&lt;&gt;(c);</span>
<span class="fc" id="L74">  }</span>

  public String getExecutable() {
<span class="fc" id="L77">    return arguments.get(0);</span>
  }

  /**
   * Removes the first System property.
   * @param pname the name of the system property to remove.
   * @return the value of the removed system property. or null if there is no such property.
   */
  @Nullable
  public String removeSystemProperty(final String pname) {
<span class="fc" id="L87">    Iterator&lt;String&gt; itr = arguments.iterator();</span>
<span class="fc" id="L88">    itr.next(); // skip command.</span>
<span class="fc" id="L89">    int nl = pname.length();</span>
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">    while (itr.hasNext()) {</span>
<span class="fc" id="L91">      String s = itr.next();</span>
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">      if (s.startsWith(&quot;-D&quot;)) {</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">        if (s.regionMatches(2, pname, 0, nl)) {</span>
<span class="fc" id="L94">          int l = nl + 2;</span>
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">          if (s.length() == l) {</span>
<span class="nc" id="L96">            itr.remove();</span>
<span class="nc" id="L97">            return &quot;&quot;;</span>
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">          } else if (s.charAt(l) == '=') {</span>
<span class="fc" id="L99">            itr.remove();</span>
<span class="fc" id="L100">            return s.substring(l + 1);</span>
          }
        }
      }
<span class="nc" id="L104">    }</span>
<span class="nc" id="L105">    return null;</span>
  }

  @Nullable
  public String getSystemProperty(final String pname) {
<span class="fc" id="L110">    Iterator&lt;String&gt; itr = arguments.iterator();</span>
<span class="fc" id="L111">    itr.next(); // skip command.</span>
<span class="fc" id="L112">    int nl = pname.length();</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">    while (itr.hasNext()) {</span>
<span class="fc" id="L114">      String s = itr.next();</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">      if (s.startsWith(&quot;-D&quot;)) {</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">        if (s.regionMatches(2, pname, 0, nl)) {</span>
<span class="fc" id="L117">          int l = nl + 2;</span>
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">          if (s.length() == l) {</span>
<span class="nc" id="L119">            return &quot;&quot;;</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">          } else if (s.charAt(l) == '=') {</span>
<span class="fc" id="L121">            return s.substring(l + 1);</span>
          }
        }
      }
<span class="fc" id="L125">    }</span>
<span class="fc" id="L126">    return null;</span>
  }


  @Nullable
  public void createOrUpdateSystemProperty(final String pname, final Function&lt;String, String&gt; replacer) {
<span class="fc" id="L132">    ListIterator&lt;String&gt; itr = arguments.listIterator();</span>
<span class="fc" id="L133">    itr.next(); // skip command.</span>
<span class="fc" id="L134">    int nl = pname.length();</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">    while (itr.hasNext()) {</span>
<span class="fc" id="L136">      String s = itr.next();</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">      if (s.startsWith(&quot;-D&quot;)) {</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">        if (s.regionMatches(2, pname, 0, nl)) {</span>
<span class="fc" id="L139">          int l = nl + 2;</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">          if (s.length() == l) {</span>
<span class="nc" id="L141">            itr.set(&quot;-D&quot; + pname + '=' + replacer.apply(&quot;&quot;));</span>
<span class="nc" id="L142">            return;</span>
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">          } else if (s.charAt(l) == '=') {</span>
<span class="fc" id="L144">            itr.set(&quot;-D&quot; + pname + '=' + replacer.apply(s.substring(l + 1)));</span>
<span class="fc" id="L145">            return;</span>
          }
        }
      }
<span class="fc" id="L149">    }</span>
<span class="fc" id="L150">    arguments.add(1, &quot;-D&quot; + pname + '=' + replacer.apply(null));</span>
<span class="fc" id="L151">  }</span>


  public boolean hasSystemProperty(final String pname) {
<span class="nc" id="L155">    Iterator&lt;String&gt; itr = arguments.iterator();</span>
<span class="nc" id="L156">    itr.next(); // skip command.</span>
<span class="nc" id="L157">    int nl = pname.length();</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">    while (itr.hasNext()) {</span>
<span class="nc" id="L159">      String s = itr.next();</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">      if (s.startsWith(&quot;-D&quot;)) {</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">        if (s.regionMatches(2, pname, 0, nl)) {</span>
<span class="nc" id="L162">          int l = nl + 2;</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">          if (s.length() == l) {</span>
<span class="nc" id="L164">            return true;</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">          } else if (s.charAt(l) == '=') {</span>
<span class="nc" id="L166">            return true;</span>
          }
        }
      }
<span class="nc" id="L170">    }</span>
<span class="nc" id="L171">    return false;</span>
  }
  /**
   * remove all system properties starting with a prefix.
   * @param pname the prefix
   * @return number of system properties removed.
   */
  public int removeAllSystemPropertiesStartingWith(final String pname) {
<span class="fc" id="L179">    String name = &quot;-D&quot; + pname;</span>
<span class="fc" id="L180">    int nrRemoved = 0;</span>
<span class="fc" id="L181">    Iterator&lt;String&gt; itr = arguments.iterator();</span>
<span class="fc" id="L182">    itr.next();</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">    while (itr.hasNext()) {</span>
<span class="fc" id="L184">      String s = itr.next();</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">      if (s.startsWith(name)) {</span>
<span class="fc" id="L186">        itr.remove();</span>
<span class="fc" id="L187">        nrRemoved++;</span>
      }
<span class="fc" id="L189">    }</span>
<span class="fc" id="L190">    return nrRemoved;</span>
  }

  public void setSystemProperty(final String name, final String value) {
<span class="nc" id="L194">    removeSystemProperty(name);</span>
    // index 0 is the executable name
<span class="nc" id="L196">    arguments.add(1, &quot;-D&quot; + name + '=' + value);</span>
<span class="nc" id="L197">  }</span>

  public void setVMArgument(final String argument) {
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">    if (!hasVMArgument(argument)) {</span>
<span class="fc" id="L201">      arguments.add(1, argument);</span>
    }
<span class="fc" id="L203">  }</span>

  public boolean removeVMArgument(final String argument) {
<span class="fc" id="L206">    Iterator&lt;String&gt; itr = arguments.iterator();</span>
<span class="fc" id="L207">    itr.next();</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">    while (itr.hasNext()) {</span>
<span class="fc" id="L209">      String s = itr.next();</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">      if (s.equals(argument)) {</span>
<span class="fc" id="L211">        itr.remove();</span>
<span class="fc" id="L212">        return true;</span>
      }
<span class="nc" id="L214">    }</span>
<span class="nc" id="L215">    return false;</span>
  }

  public boolean hasVMArgument(final String argument) {
<span class="fc" id="L219">    Iterator&lt;String&gt; itr = arguments.iterator();</span>
<span class="fc" id="L220">    itr.next();</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">    while (itr.hasNext()) {</span>
<span class="fc" id="L222">      String s = itr.next();</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">      if (s.equals(argument)) {</span>
<span class="fc" id="L224">        return true;</span>
      }
<span class="fc" id="L226">    }</span>
<span class="fc" id="L227">    return false;</span>
  }

  public boolean hasVMArgumentStartingWith(final String argumentPrefix) {
<span class="fc" id="L231">    Iterator&lt;String&gt; itr = arguments.iterator();</span>
<span class="fc" id="L232">    itr.next();</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">    while (itr.hasNext()) {</span>
<span class="fc" id="L234">      String s = itr.next();</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">      if (s.startsWith(argumentPrefix)) {</span>
<span class="fc" id="L236">        return true;</span>
      }
<span class="nc" id="L238">    }</span>
<span class="nc" id="L239">    return false;</span>
  }


  public void add(final String arg) {
<span class="fc" id="L244">    arguments.add(arg);</span>
<span class="fc" id="L245">  }</span>

  /**
   * Removes the n items from the end. Useful for removing all the Java arguments to rebuild them.
   */
  public void removeTail(final int n) {
<span class="nc" id="L251">    int size = arguments.size();</span>
<span class="nc" id="L252">    arguments.removeAll(arguments.subList(size - n, size));</span>
<span class="nc" id="L253">  }</span>

  public StringArray toStringArray() {
<span class="nc" id="L256">    return new StringArray(arguments.toArray(new String[arguments.size()]));</span>
  }

  /**
   * Gets the process argument list of the current process.
   */
  public static JVMArguments current() throws IOException {
<span class="fc" id="L263">    return of(-1);</span>
  }

  /**
   * Gets the process argument list of the specified process ID.
   *
   * @param pid -1 to indicate the current process.
   */
  public static JVMArguments of(final int pid) throws IOException {
<span class="fc" id="L272">    String os = Runtime.OS_NAME;</span>
<span class="pc bpc" id="L273" title="4 of 5 branches missed.">    switch (os) {</span>
      case &quot;Linux&quot;:
<span class="nc" id="L275">        return ofLinux(pid);</span>
      case &quot;SunOS&quot;:
<span class="nc" id="L277">        return ofSolaris(pid);</span>
      case &quot;Mac OS X&quot;:
<span class="fc" id="L279">        return ofMac(pid);</span>
      case &quot;FreeBSD&quot;:
<span class="nc" id="L281">        return ofFreeBSD(pid);</span>
      default:
<span class="nc" id="L283">        throw new UnsupportedOperationException(&quot;Unsupported Operating System &quot; + os);</span>
    }
  }

  private static JVMArguments ofLinux(final int ppid) throws IOException {
<span class="nc" id="L288">    int pid = resolvePID(ppid);</span>
<span class="nc" id="L289">    String cmdline = Files.asCharSource(new File(&quot;/proc/&quot; + pid + &quot;/cmdline&quot;), Charset.defaultCharset()).read();</span>
<span class="nc" id="L290">    return new JVMArguments(java.util.Arrays.asList(cmdline.split(&quot;\0&quot;)));</span>
  }

  private static int resolvePID(final int pid) {
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">    if (pid == -1) {</span>
<span class="fc" id="L295">      return Runtime.PID;</span>
    } else {
<span class="nc" id="L297">      return pid;</span>
    }
  }

  private static JVMArguments ofSolaris(final int ppid) throws IOException {
    // /proc shows different contents based on the caller's memory model, so we need to know if we are 32 or 64.
    // 32 JVMs are the norm, so err on the 32bit side.
<span class="nc" id="L304">    boolean areWe64 = &quot;64&quot;.equals(System.getProperty(&quot;sun.arch.data.model&quot;));</span>
<span class="nc" id="L305">    int pid = resolvePID(ppid);</span>
<span class="nc" id="L306">    try (RandomAccessFile psinfo = new RandomAccessFile(new File(&quot;/proc/&quot; + pid + &quot;/psinfo&quot;), &quot;r&quot;)) {</span>
      // see http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/sys/procfs.h
      //typedef struct psinfo {
      // int pr_flag; /* process flags */
      // int pr_nlwp; /* number of lwps in the process */
      // pid_t pr_pid; /* process id */
      // pid_t pr_ppid; /* process id of parent */
      // pid_t pr_pgid; /* process id of process group leader */
      // pid_t pr_sid; /* session id */
      // uid_t pr_uid; /* real user id */
      // uid_t pr_euid; /* effective user id */
      // gid_t pr_gid; /* real group id */
      // gid_t pr_egid; /* effective group id */
      // uintptr_t pr_addr; /* address of process */
      // size_t pr_size; /* size of process image in Kbytes */
      // size_t pr_rssize; /* resident set size in Kbytes */
      // dev_t pr_ttydev; /* controlling tty device (or PRNODEV) */
      // ushort_t pr_pctcpu; /* % of recent cpu time used by all lwps */
      // ushort_t pr_pctmem; /* % of system memory used by process */
      // timestruc_t pr_start; /* process start time, from the epoch */
      // timestruc_t pr_time; /* cpu time for this process */
      // timestruc_t pr_ctime; /* cpu time for reaped children */
      // char pr_fname[PRFNSZ]; /* name of exec'ed file */
      // char pr_psargs[PRARGSZ]; /* initial characters of arg list */
      // int pr_wstat; /* if zombie, the wait() status */
      // int pr_argc; /* initial argument count */
      // uintptr_t pr_argv; /* address of initial argument vector */
      // uintptr_t pr_envp; /* address of initial environment vector */
      // char pr_dmodel; /* data model of the process */
      // lwpsinfo_t pr_lwp; /* information for representative lwp */
      //} psinfo_t;

      // see http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/sys/types.h
      // for the size of the various datatype.
      // see http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/cmd/ptools/pargs/pargs.c
      // for how to read this information
<span class="nc" id="L342">      psinfo.seek(8);</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">      if (adjust(psinfo.readInt()) != pid) {</span>
<span class="nc" id="L344">        throw new IOException(&quot;psinfo PID mismatch: &quot; + pid + &quot;, &quot; + psinfo);   // sanity check</span>
      }
      /* The following program computes the offset:
                    #include &lt;stdio.h&gt;
                    #include &lt;sys/procfs.h&gt;
                    int main() {
                      printf(&quot;psinfo_t = %d\n&quot;, sizeof(psinfo_t));
                      psinfo_t *x;
                      x = 0;
                      printf(&quot;%x\n&quot;, &amp;(x-&gt;pr_argc));
                    }
       */

<span class="nc bnc" id="L357" title="All 2 branches missed.">      psinfo.seek(areWe64 ? 0xEC : 0xBC);  // now jump to pr_argc</span>
<span class="nc" id="L358">      int argc = adjust(psinfo.readInt());</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">      long argp = areWe64 ? adjust(psinfo.readLong()) : to64(adjust(psinfo.readInt()));</span>
<span class="nc" id="L360">      File asFile = new File(&quot;/proc/&quot; + pid + &quot;/as&quot;);</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">      if (areWe64) {</span>
        // 32bit and 64bit basically does the same thing, but because the stream position
        // is computed with signed long, doing 64bit seek to a position bigger than Long.MAX_VALUE
        // requres some real hacking. Hence two different code path.
        // (RandomAccessFile uses Java long for offset, so it just can't get to anywhere beyond Long.MAX_VALUE)
<span class="nc" id="L366">        FILE fp = CLibrary.INSTANCE.fopen(asFile.getPath(), &quot;r&quot;);</span>
        try {
<span class="nc" id="L368">          JVMArguments args = new JVMArguments(16);</span>
<span class="nc" id="L369">          Memory m = new Memory(8);</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">          for (int n = 0; n &lt; argc; n++) {</span>
            // read a pointer to one entry
<span class="nc" id="L372">            seek64(fp, argp + ((long) n) * 8);</span>
<span class="nc" id="L373">            m.setLong(0, 0); // just to make sure failed read won't result in bogus value</span>
<span class="nc" id="L374">            CLibrary.INSTANCE.fread(m, 1, 8, fp);</span>
<span class="nc" id="L375">            long p = m.getLong(0);</span>
<span class="nc" id="L376">            args.add(readLine(fp, p));</span>
          }
<span class="nc" id="L378">          return args;</span>
        } finally {
<span class="nc" id="L380">          CLibrary.INSTANCE.fclose(fp);</span>
        }
      } else {
<span class="nc" id="L383">        try (RandomAccessFile as = new RandomAccessFile(asFile, &quot;r&quot;)) {</span>
<span class="nc" id="L384">          JVMArguments args = new JVMArguments(16);</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">          for (int n = 0; n &lt; argc; n++) {</span>
            // read a pointer to one entry
<span class="nc" id="L387">            as.seek(argp + n * 4);</span>
<span class="nc" id="L388">            int p = adjust(as.readInt());</span>

<span class="nc" id="L390">            args.add(readLine(as, p));</span>
          }
<span class="nc" id="L392">          return args;</span>
        }
      }
    }
  }

  /**
   * Seek to the specified position. This method handles offset bigger than {@link Long#MAX_VALUE} correctly.
   *
   * @param upos This value is interpreted as unsigned 64bit integer (even though it's typed 'long')
   */
  private static void seek64(final FILE fp, final long pupos) {
<span class="nc" id="L404">    long upos = pupos;</span>
<span class="nc" id="L405">    CLibrary.INSTANCE.fseek(fp, 0, 0); // start at the beginning</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">    while (upos &lt; 0) {</span>
<span class="nc" id="L407">      long chunk = Long.MAX_VALUE;</span>
<span class="nc" id="L408">      upos -= chunk;</span>
<span class="nc" id="L409">      CLibrary.INSTANCE.fseek(fp, chunk, 1);</span>
<span class="nc" id="L410">    }</span>
<span class="nc" id="L411">    CLibrary.INSTANCE.fseek(fp, upos, 1);</span>
<span class="nc" id="L412">  }</span>

  /**
   * {@link DataInputStream} reads a value in big-endian, so convert it to the correct value on little-endian systems.
   */
  private static int adjust(final int i) {
<span class="nc bnc" id="L418" title="All 2 branches missed.">    if (Runtime.IS_LITTLE_ENDIAN) {</span>
<span class="nc" id="L419">      return (i &lt;&lt; 24) | ((i &lt;&lt; 8) &amp; 0x00FF0000) | ((i &gt;&gt; 8) &amp; 0x0000FF00) | (i &gt;&gt;&gt; 24);</span>
    } else {
<span class="nc" id="L421">      return i;</span>
    }
  }

  private static long adjust(final long i) {
<span class="nc bnc" id="L426" title="All 2 branches missed.">    if (Runtime.IS_LITTLE_ENDIAN) {</span>
<span class="nc" id="L427">      return (i &lt;&lt; 56)</span>
              | ((i &lt;&lt; 40) &amp; 0x00FF000000000000L)
              | ((i &lt;&lt; 24) &amp; 0x0000FF0000000000L)
              | ((i &lt;&lt; 8) &amp; 0x000000FF00000000L)
              | ((i &gt;&gt; 8) &amp; 0x00000000FF000000L)
              | ((i &gt;&gt; 24) &amp; 0x0000000000FF0000L)
              | ((i &gt;&gt; 40) &amp; 0x000000000000FF00L)
              | (i &gt;&gt; 56);
    } else {
<span class="nc" id="L436">      return i;</span>
    }
  }

  /**
   * int to long conversion with zero-padding.
   */
  private static long to64(final int i) {
<span class="nc" id="L444">    return i &amp; 0xFFFFFFFFL;</span>
  }

  private static String readLine(final RandomAccessFile as, final int p) throws IOException {
<span class="nc" id="L448">    as.seek(to64(p));</span>
<span class="nc" id="L449">    ByteArrayOutputStream buf = new ByteArrayOutputStream();</span>
    int ch;
<span class="nc bnc" id="L451" title="All 2 branches missed.">    while ((ch = as.read()) &gt; 0) {</span>
<span class="nc" id="L452">      buf.write(ch);</span>
    }
<span class="nc" id="L454">    return buf.toString();</span>
  }

  private static String readLine(final FILE as, final long p) {
<span class="nc" id="L458">    seek64(as, p);</span>
<span class="nc" id="L459">    Memory m = new Memory(1);</span>
<span class="nc" id="L460">    ByteArrayOutputStream buf = new ByteArrayOutputStream();</span>
    while (true) {
<span class="nc bnc" id="L462" title="All 2 branches missed.">      if (CLibrary.INSTANCE.fread(m, 1, 1, as) == 0) {</span>
<span class="nc" id="L463">        break;</span>
      }
<span class="nc" id="L465">      byte b = m.getByte(0);</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">      if (b == 0) {</span>
<span class="nc" id="L467">        break;</span>
      }
<span class="nc" id="L469">      buf.write(b);</span>
<span class="nc" id="L470">    }</span>
<span class="nc" id="L471">    return buf.toString();</span>
  }

  /**
   * Mac support
   *
   * See http://developer.apple.com/qa/qa2001/qa1123.html http://www.osxfaq.com/man/3/kvm_getprocs.ws
   * http://matburt.net/?p=16 (libkvm is removed from OSX) where is kinfo_proc?
   * http://lists.apple.com/archives/xcode-users/2008/Mar/msg00781.html
   *
   * This code uses sysctl to get the arg/env list:
   * http://www.psychofx.com/psi/trac/browser/psi/trunk/src/arch/macosx/macosx_process.c which came from
   * http://www.opensource.apple.com/darwinsource/10.4.2/top-15/libtop.c
   *
   * sysctl is defined in libc.
   *
   * PS source code for Mac: http://www.opensource.apple.com/darwinsource/10.4.1/adv_cmds-79.1/ps.tproj/
   */
  @SuppressFBWarnings(&quot;PRMC_POSSIBLY_REDUNDANT_METHOD_CALLS&quot;)
  private static JVMArguments ofMac(final int pid) {
    // local constants
<span class="fc" id="L492">    final int ctlKern = 1;</span>
<span class="fc" id="L493">    final int kernArgMax = 8;</span>
<span class="fc" id="L494">    final int kernProcArgs2 = 49;</span>
<span class="fc" id="L495">    final int sizeOfInt = Native.getNativeSize(int.class);</span>
<span class="fc" id="L496">    IntByReference ibf = new IntByReference();</span>

<span class="fc" id="L498">    IntByReference argmaxRef = new IntByReference(0);</span>
<span class="fc" id="L499">    IntByReference size = new IntByReference(sizeOfInt);</span>

    // for some reason, I was never able to get sysctlbyname work.
//        if(LIBC.sysctlbyname(&quot;kern.argmax&quot;, argmaxRef.getPointer(), size, NULL, ibf)!=0)
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">    if (CLibrary.INSTANCE.sysctl(new int[]{ctlKern, kernArgMax}, 2, argmaxRef.getPointer(), size, NULL, ibf) != 0) {</span>
<span class="nc" id="L504">      throw new UnsupportedOperationException(&quot;Failed to get kernl.argmax: &quot;</span>
<span class="nc" id="L505">              + CLibrary.INSTANCE.strerror(Native.getLastError()));</span>
    }

<span class="fc" id="L508">    int argmax = argmaxRef.getValue();</span>
<span class="fc" id="L509">    StringArrayMemory m = new StringArrayMemory(argmax, sizeOfInt);</span>
<span class="fc" id="L510">    size.setValue(argmax);</span>
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">    if (CLibrary.INSTANCE.sysctl(new int[]{ctlKern, kernProcArgs2, resolvePID(pid)}, 3, m, size, NULL, ibf) != 0) {</span>
<span class="nc" id="L512">      throw new UnsupportedOperationException(&quot;Failed to obtain ken.procargs2: &quot;</span>
<span class="nc" id="L513">              + CLibrary.INSTANCE.strerror(Native.getLastError()));</span>
    }
    /*
         * Make a sysctl() call to get the raw argument space of the
         * process.  The layout is documented in start.s, which is part
         * of the Csu project.  In summary, it looks like:
         *
         * /---------------\ 0x00000000
         * :               :
         * :               :
         * |---------------|
         * | argc          |
         * |---------------|
         * | arg[0]        |
         * |---------------|
         * :               :
         * :               :
         * |---------------|
         * | arg[argc - 1] |
         * |---------------|
         * | 0             |
         * |---------------|
         * | env[0]        |
         * |---------------|
         * :               :
         * :               :
         * |---------------|
         * | env[n]        |
         * |---------------|
         * | 0             |
         * |---------------| &lt;-- Beginning of data returned by sysctl()
         * | exec_path     |     is here.
         * |:::::::::::::::|
         * |               |
         * | String area.  |
         * |               |
         * |---------------| &lt;-- Top of stack.
         * :               :
         * :               :
         * \---------------/ 0xffffffff
     */
<span class="fc" id="L554">    int nargs = m.readInt();</span>
<span class="fc" id="L555">    JVMArguments args = new JVMArguments(nargs);</span>
<span class="fc" id="L556">    m.readString(); // exec path</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">    for (int i = 0; i &lt; nargs; i++) {</span>
<span class="fc" id="L558">      m.skip0();</span>
<span class="fc" id="L559">      args.add(m.readString());</span>
    }
<span class="fc" id="L561">    return args;</span>
  }

  @SuppressFBWarnings(&quot;EQ_DOESNT_OVERRIDE_EQUALS&quot;)
  private static final class StringArrayMemory extends Memory {

<span class="fc" id="L567">    private long offset = 0;</span>
    private final int sizeOfInt;

    StringArrayMemory(final long l, final int sizeOfInt) {
<span class="fc" id="L571">      super(l);</span>
<span class="fc" id="L572">      this.sizeOfInt = sizeOfInt;</span>
<span class="fc" id="L573">    }</span>

    private int readInt() {
<span class="fc" id="L576">      int r = getInt(offset);</span>
<span class="fc" id="L577">      offset += sizeOfInt;</span>
<span class="fc" id="L578">      return r;</span>
    }

    private String readString() {
<span class="fc" id="L582">      ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
      byte ch;
<span class="fc bfc" id="L584" title="All 2 branches covered.">      while ((ch = getByte(offset++)) != '\0') {</span>
<span class="fc" id="L585">        baos.write(ch);</span>
      }
<span class="fc" id="L587">      return baos.toString();</span>
    }

    void skip0() {
      // skip trailing '\0's
<span class="fc bfc" id="L592" title="All 2 branches covered.">      while (getByte(offset) == '\0') {</span>
<span class="fc" id="L593">        offset++;</span>
      }
<span class="fc" id="L595">    }</span>
  }

  private static JVMArguments ofFreeBSD(final int pid) {
    // taken from sys/sysctl.h
<span class="nc" id="L600">    final int ctlKern = 1;</span>
<span class="nc" id="L601">    final int kernArgMax = 8;</span>
<span class="nc" id="L602">    final int kernProc = 14;</span>
<span class="nc" id="L603">    final int kernProcArgs = 7;</span>

<span class="nc" id="L605">    IntByReference ibr = new IntByReference();</span>
<span class="nc" id="L606">    IntByReference sysctlArgMax = new IntByReference();</span>
<span class="nc" id="L607">    IntByReference size = new IntByReference();</span>

<span class="nc" id="L609">    size.setValue(4);</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">    if (CLibrary.INSTANCE.sysctl(new int[]{ctlKern, kernArgMax},</span>
<span class="nc" id="L611">            2, sysctlArgMax.getPointer(), size, NULL, ibr) != 0) {</span>
<span class="nc" id="L612">      throw new UnsupportedOperationException(&quot;Failed to sysctl kern.argmax&quot;);</span>
    }

<span class="nc" id="L615">    int argmax = sysctlArgMax.getValue();</span>
<span class="nc" id="L616">    Memory m = new Memory(argmax);</span>
<span class="nc" id="L617">    size.setValue(argmax);</span>

<span class="nc bnc" id="L619" title="All 2 branches missed.">    if (CLibrary.INSTANCE.sysctl(new int[]{ctlKern, kernProc, kernProcArgs, resolvePID(pid)},</span>
            4, m, size, NULL, ibr) != 0) {
<span class="nc" id="L621">      throw new UnsupportedOperationException();</span>
    }

<span class="nc" id="L624">    ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L625">    ArrayList&lt;String&gt; lArgs = new ArrayList&lt;String&gt;();</span>
    byte ch;
<span class="nc" id="L627">    int offset = 0;</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">    while (offset &lt; size.getValue()) {</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">      while ((ch = m.getByte(offset++)) != '\0') {</span>
<span class="nc" id="L630">        baos.write(ch);</span>
      }
<span class="nc" id="L632">      lArgs.add(baos.toString());</span>
<span class="nc" id="L633">      baos.reset();</span>
    }

<span class="nc" id="L636">    return new JVMArguments(lArgs);</span>
  }

  @Override
  public String toString() {
<span class="fc" id="L641">    return &quot;JVMArguments{&quot; + &quot;arguments=&quot; + arguments + '}';</span>
  }

  @Override
  public int hashCode() {
<span class="nc" id="L646">    return 11 * 7 + Objects.hashCode(this.arguments);</span>
  }

  @Override
  public boolean equals(final Object obj) {
<span class="nc bnc" id="L651" title="All 2 branches missed.">    if (this == obj) {</span>
<span class="nc" id="L652">      return true;</span>
    }
<span class="nc bnc" id="L654" title="All 2 branches missed.">    if (obj == null) {</span>
<span class="nc" id="L655">      return false;</span>
    }
<span class="nc bnc" id="L657" title="All 2 branches missed.">    if (getClass() != obj.getClass()) {</span>
<span class="nc" id="L658">      return false;</span>
    }
<span class="nc" id="L660">    final JVMArguments other = (JVMArguments) obj;</span>
<span class="nc" id="L661">    return Objects.equals(this.arguments, other.arguments);</span>
  }

  public String[] toArray() {
<span class="fc" id="L665">    return arguments.toArray(new String[arguments.size()]);</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>