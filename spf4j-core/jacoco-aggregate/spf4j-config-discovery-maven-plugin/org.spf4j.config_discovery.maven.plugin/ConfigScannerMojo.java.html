<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ConfigScannerMojo.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">spf4j-core</a> &gt; <a href="../index.html" class="el_bundle">spf4j-config-discovery-maven-plugin</a> &gt; <a href="index.source.html" class="el_package">org.spf4j.config_discovery.maven.plugin</a> &gt; <span class="el_source">ConfigScannerMojo.java</span></div><h1>ConfigScannerMojo.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2001-2017, Zoltan Farkas All Rights Reserved.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * Additionally licensed with:
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.spf4j.config_discovery.maven.plugin;

import com.google.common.base.CaseFormat;
import com.google.common.collect.ImmutableSet;
import java.io.BufferedInputStream;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.lang.reflect.Method;
import java.util.Set;
import com.google.common.base.Supplier;
import java.io.UncheckedIOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.annotation.Nonnull;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.spf4j.base.asm.Invocation;
import org.spf4j.base.asm.Scanner;

@Mojo(name = &quot;generate&quot;, defaultPhase = LifecyclePhase.PROCESS_CLASSES, requiresProject = true)
<span class="nc" id="L64">public class ConfigScannerMojo</span>
        extends AbstractMojo {

<span class="nc" id="L67">  public static final Map&lt;Class, String&gt; JAVA2AVROTYPE = new HashMap&lt;&gt;();</span>

  static {
<span class="nc" id="L70">    JAVA2AVROTYPE.put(String.class, &quot;string&quot;);</span>
<span class="nc" id="L71">    JAVA2AVROTYPE.put(Integer.class, &quot;int&quot;);</span>
<span class="nc" id="L72">    JAVA2AVROTYPE.put(int.class, &quot;int&quot;);</span>
<span class="nc" id="L73">    JAVA2AVROTYPE.put(Long.class, &quot;long&quot;);</span>
<span class="nc" id="L74">    JAVA2AVROTYPE.put(long.class, &quot;long&quot;);</span>
<span class="nc" id="L75">    JAVA2AVROTYPE.put(Boolean.class, &quot;boolean&quot;);</span>
<span class="nc" id="L76">    JAVA2AVROTYPE.put(boolean.class, &quot;boolean&quot;);</span>
<span class="nc" id="L77">    JAVA2AVROTYPE.put(Float.class, &quot;float&quot;);</span>
<span class="nc" id="L78">    JAVA2AVROTYPE.put(float.class, &quot;float&quot;);</span>
<span class="nc" id="L79">    JAVA2AVROTYPE.put(Double.class, &quot;double&quot;);</span>
<span class="nc" id="L80">    JAVA2AVROTYPE.put(double.class, &quot;double&quot;);</span>
<span class="nc" id="L81">    JAVA2AVROTYPE.put(Map.class, &quot;map&lt;string&gt;&quot;);</span>
<span class="nc" id="L82">  }</span>

  /**
   * Location of the file.
   */
  @Parameter(defaultValue = &quot;${project.build.directory}/generated-sources/avdl&quot;,
          property = &quot;outputDir&quot;, required = true)
  private File outputDirectory;

  @Parameter(defaultValue = &quot;${project.artifactId}.avdl&quot;,
          property = &quot;outputFile&quot;, required = true)
  private String fileName;

  @Parameter(defaultValue = &quot;${project.build.sourceEncoding}&quot;)
  private String encoding;

  @Parameter(defaultValue = &quot;SystemProperties&quot;)
  private String rootRecordName;

  @Parameter(defaultValue = &quot;Config&quot;)
  private String recordSuffix;

  @Parameter(defaultValue = &quot;${project.build.directory}/classes&quot;)
  private File classes;

  /**
   * target namespace of the configurations.
   */
<span class="nc" id="L110">  @Parameter(defaultValue = &quot;&quot;)</span>
  private String namespace = &quot;&quot;;

<span class="nc" id="L113">  private final Set&lt;Method&gt; methods = getSystemPropertyMethods();</span>

  private static Set&lt;Method&gt; getSystemPropertyMethods() {
    try {
<span class="nc" id="L117">      return ImmutableSet.of(System.class.getDeclaredMethod(&quot;getProperty&quot;, String.class),</span>
<span class="nc" id="L118">              System.class.getDeclaredMethod(&quot;getProperty&quot;, String.class, String.class),</span>
<span class="nc" id="L119">              Integer.class.getDeclaredMethod(&quot;getInteger&quot;, String.class),</span>
<span class="nc" id="L120">              Integer.class.getDeclaredMethod(&quot;getInteger&quot;, String.class, int.class),</span>
<span class="nc" id="L121">              Integer.class.getDeclaredMethod(&quot;getInteger&quot;, String.class, Integer.class),</span>
<span class="nc" id="L122">              Long.class.getDeclaredMethod(&quot;getLong&quot;, String.class),</span>
<span class="nc" id="L123">              Long.class.getDeclaredMethod(&quot;getLong&quot;, String.class, Long.class),</span>
<span class="nc" id="L124">              Long.class.getDeclaredMethod(&quot;getLong&quot;, String.class, long.class),</span>
<span class="nc" id="L125">              Boolean.class.getDeclaredMethod(&quot;getBoolean&quot;, String.class));</span>
<span class="nc" id="L126">    } catch (NoSuchMethodException ex) {</span>
<span class="nc" id="L127">      throw new ExceptionInInitializerError(ex);</span>
    }
  }

  public static String greatestCommonPrefix(final String a, final String b) {
<span class="nc" id="L132">    int minLength = Math.min(a.length(), b.length());</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">    for (int i = 0; i &lt; minLength; i++) {</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">      if (a.charAt(i) != b.charAt(i)) {</span>
<span class="nc" id="L135">        return a.substring(0, i);</span>
      }
    }
<span class="nc" id="L138">    return a.substring(0, minLength);</span>
  }

  @Nonnull
  public static String getPackageName(final String className) {
<span class="nc" id="L143">    int lastIndexOf = className.lastIndexOf('/');</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">    if (lastIndexOf &gt;= 0) {</span>
<span class="nc" id="L145">      return className.substring(0, lastIndexOf).replace('/', '.');</span>
    } else {
<span class="nc" id="L147">      return &quot;&quot;;</span>
    }
  }


  public void processClasses(final File location, final Map&lt;String, Object&gt; avdlWriter) throws IOException {
<span class="nc bnc" id="L153" title="All 2 branches missed.">    if (!location.exists()) {</span>
<span class="nc" id="L154">      return;</span>
    }
<span class="nc bnc" id="L156" title="All 2 branches missed.">    if (location.isDirectory()) {</span>
<span class="nc" id="L157">      File[] listFiles = location.listFiles();</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">      if (listFiles != null) {</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">        for (File file : listFiles) {</span>
<span class="nc" id="L160">          processClasses(file, avdlWriter);</span>
        }
      }
<span class="nc bnc" id="L163" title="All 2 branches missed.">    } else if (location.getName().endsWith(&quot;.class&quot;)) {</span>
<span class="nc" id="L164">      getLog().debug(&quot;Processing class &quot; + location);</span>
<span class="nc" id="L165">      List&lt;Invocation&gt; invocations = Scanner.findUsages(new Supplier&lt;InputStream&gt;() {</span>

        @Override
        public InputStream get() {
          try {
<span class="nc" id="L170">            return new BufferedInputStream(new FileInputStream(location));</span>
<span class="nc" id="L171">          } catch (FileNotFoundException ex) {</span>
<span class="nc" id="L172">            throw new UncheckedIOException(ex);</span>
          }
        }
      }, methods);
<span class="nc bnc" id="L176" title="All 2 branches missed.">      for (Invocation invocation : invocations) {</span>
<span class="nc" id="L177">        getLog().debug(&quot;Found invocation &quot; + invocation);</span>
<span class="nc" id="L178">        Class&lt;?&gt; returnType = invocation.getInvokedMethod().getReturnType();</span>
<span class="nc" id="L179">        Object[] parameters = invocation.getParameters();</span>
<span class="nc" id="L180">        String caleeClassName = invocation.getCaleeClassName();</span>
<span class="nc" id="L181">        String doc = caleeClassName</span>
<span class="nc" id="L182">                + '.' + invocation.getCaleeMethodName() + ':' + invocation.getCaleeLine();</span>
<span class="nc" id="L183">        Object parameter = parameters[0];</span>
<span class="nc" id="L184">        Map&lt;String, Object&gt; objs = avdlWriter;</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">        if (parameter instanceof String) {</span>
<span class="nc" id="L186">          String[] attrPath = ((String) parameter).split(&quot;\\.&quot;);</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">          for (int i = 0; i &lt; attrPath.length - 1; i++) {</span>
<span class="nc" id="L188">            final String pv = attrPath[i];</span>
<span class="nc" id="L189">            Map&lt;String, Object&gt; get = (Map&lt;String, Object&gt;) objs.get(pv);</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">            if (get == null) {</span>
<span class="nc" id="L191">              get = new HashMap&lt;&gt;();</span>
<span class="nc" id="L192">              objs.put(pv, get);</span>
            }
<span class="nc" id="L194">            objs = get;</span>
          }
<span class="nc" id="L196">          String fname = attrPath[attrPath.length - 1];</span>
<span class="nc" id="L197">          FieldInfo fi = (FieldInfo) objs.get(fname);</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">          if (fi == null) {</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">            if (parameters.length &gt; 1) {</span>
<span class="nc" id="L200">              fi = new FieldInfo(getPackageName(caleeClassName), doc, returnType, parameters[1]);</span>
            } else {
<span class="nc" id="L202">              fi = new FieldInfo(getPackageName(caleeClassName), doc, returnType, null);</span>
            }
<span class="nc" id="L204">            objs.put(fname, fi);</span>
          }
<span class="nc" id="L206">        } else {</span>
<span class="nc" id="L207">          FieldInfo df = (FieldInfo) objs.get(&quot;dynamic&quot;);</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">          if (df == null) {</span>
<span class="nc" id="L209">            df = new FieldInfo(getPackageName(caleeClassName), doc, Map.class, Collections.EMPTY_MAP);</span>
          } else {
<span class="nc" id="L211">            df = new FieldInfo(getPackageName(caleeClassName), df.getDoc() + '\n' + doc,</span>
                    Map.class, Collections.EMPTY_MAP);
          }
<span class="nc" id="L214">          objs.put(&quot;dynamic&quot;, df);</span>
        }

<span class="nc" id="L217">      }</span>
    }
<span class="nc" id="L219">  }</span>


  public static String childNameSpace(final String parent, final String child) {
<span class="nc bnc" id="L223" title="All 2 branches missed.">    return (parent.isEmpty()) ? child : parent + '.' + child;</span>
  }

  public void writeRecord(final Writer w, final String nameSpace,
          final String recordName, final Map&lt;String, Object&gt; record)
          throws IOException {
    // do subRecords first.
<span class="nc bnc" id="L230" title="All 2 branches missed.">    for (Map.Entry&lt;String, Object&gt; entry : record.entrySet()) {</span>
<span class="nc" id="L231">      Object value = entry.getValue();</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">      if (value instanceof Map) {</span>
<span class="nc" id="L233">        String key = entry.getKey();</span>
<span class="nc" id="L234">        writeRecord(w, childNameSpace(nameSpace, key),</span>
<span class="nc" id="L235">                CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_CAMEL, key) + recordSuffix,</span>
                (Map&lt;String, Object&gt;) value);
<span class="nc bnc" id="L237" title="All 2 branches missed.">      } else if (!(value instanceof FieldInfo)) {</span>
<span class="nc" id="L238">        throw new IllegalStateException(&quot;Not supported type &quot; + value);</span>
      }
<span class="nc" id="L240">    }</span>
    // write record
<span class="nc bnc" id="L242" title="All 2 branches missed.">    if (!nameSpace.isEmpty()) {</span>
<span class="nc" id="L243">      w.write(&quot; @namespace(\&quot;&quot;);</span>
<span class="nc" id="L244">      w.write(nameSpace);</span>
<span class="nc" id="L245">      w.write(&quot;\&quot;)\n&quot;);</span>
    }
<span class="nc" id="L247">    w.write(&quot; record &quot;);</span>
<span class="nc" id="L248">    w.write(recordName);</span>
<span class="nc" id="L249">    w.write(&quot; {\n&quot;);</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">    for (Map.Entry&lt;String, Object&gt; entry : record.entrySet()) {</span>
<span class="nc" id="L251">      Object value = entry.getValue();</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">      if (value instanceof FieldInfo) {</span>
<span class="nc" id="L253">        FieldInfo field = (FieldInfo) value;</span>
<span class="nc" id="L254">        w.write(&quot;\n  /**&quot;);</span>
<span class="nc" id="L255">        w.write(field.getDoc());</span>
<span class="nc" id="L256">        w.write(&quot;*/\n&quot;);</span>
<span class="nc" id="L257">        Class type = field.getType();</span>
<span class="nc" id="L258">        Object defaultValue = field.getDefaultValue();</span>
<span class="nc" id="L259">        String avroType = JAVA2AVROTYPE.get(type);</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">        if (avroType == null) {</span>
<span class="nc" id="L261">          throw new IllegalStateException(&quot; No avro equivalent for &quot; + type);</span>
        }
<span class="nc bnc" id="L263" title="All 4 branches missed.">        if (type == boolean.class || type == Boolean.class) {</span>
<span class="nc" id="L264">          defaultValue = false;</span>
        }
<span class="nc bnc" id="L266" title="All 2 branches missed.">        if (defaultValue == null) {</span>
<span class="nc" id="L267">          w.write(&quot;  union {null, &quot;);</span>
<span class="nc" id="L268">          w.write(avroType);</span>
<span class="nc" id="L269">          w.write(&quot;} &quot;);</span>
        } else {
<span class="nc" id="L271">          w.write(&quot;  &quot;);</span>
<span class="nc" id="L272">          w.write(avroType);</span>
<span class="nc" id="L273">          w.write(&quot; &quot;);</span>
        }
<span class="nc" id="L275">        w.write(entry.getKey());</span>
<span class="nc" id="L276">        w.write(&quot; = &quot;);</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">        w.append(defaultValue == null ? null :</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">                defaultValue.getClass() == String.class ? JsonUtils.toJsonString((String) defaultValue)</span>
<span class="nc" id="L279">                        : defaultValue.toString());</span>
<span class="nc" id="L280">        w.write(&quot;;\n&quot;);</span>

<span class="nc bnc" id="L282" title="All 2 branches missed.">      } else if (value instanceof Map) {</span>
<span class="nc" id="L283">        String key = entry.getKey();</span>
<span class="nc" id="L284">        String ns = childNameSpace(nameSpace, key);</span>
<span class="nc" id="L285">        w.write(&quot;\n /** Category: &quot;);</span>
<span class="nc" id="L286">        w.write(key);</span>
<span class="nc" id="L287">        w.write(&quot; */\n  &quot;);</span>
<span class="nc" id="L288">        w.write(ns);</span>
<span class="nc" id="L289">        w.write('.');</span>
<span class="nc" id="L290">        w.write(CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_CAMEL, key));</span>
<span class="nc" id="L291">        w.write(recordSuffix);</span>
<span class="nc" id="L292">        w.write(&quot; &quot;);</span>
<span class="nc" id="L293">        w.write(key);</span>
<span class="nc" id="L294">        w.write(&quot;;\n&quot;);</span>
<span class="nc" id="L295">      } else {</span>
<span class="nc" id="L296">        throw new IllegalStateException(&quot;Not supported type &quot; + value);</span>
      }
<span class="nc" id="L298">    }</span>
<span class="nc" id="L299">    w.write(&quot; }\n\n&quot;);</span>
<span class="nc" id="L300">  }</span>

  @Override
  public void execute() throws MojoExecutionException {
<span class="nc" id="L304">    File f = outputDirectory;</span>

<span class="nc bnc" id="L306" title="All 2 branches missed.">    if (!f.exists()) {</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">      if (!f.mkdirs()) {</span>
<span class="nc" id="L308">        throw new MojoExecutionException(&quot;Unable to create directory &quot; + outputDirectory);</span>
      }
    }

<span class="nc" id="L312">    File outFile = new File(f, fileName);</span>
<span class="nc" id="L313">    getLog().info(&quot;Creating avdl file at &quot; + outFile);</span>
<span class="nc" id="L314">    try (Writer w = new OutputStreamWriter(new FileOutputStream(outFile), encoding)) {</span>
<span class="nc bnc" id="L315" title="All 4 branches missed.">      if (namespace != null &amp;&amp; !namespace.isEmpty()) {</span>
<span class="nc" id="L316">        w.write(&quot;@namespace(\&quot;&quot;);</span>
<span class="nc" id="L317">        w.write(namespace);</span>
<span class="nc" id="L318">        w.write(&quot;\&quot;)\n&quot;);</span>
      }
<span class="nc" id="L320">      w.write(&quot;protocol  &quot;);</span>
<span class="nc" id="L321">      w.write(rootRecordName);</span>
<span class="nc" id="L322">      w.write(&quot;Protocol&quot;);</span>
<span class="nc" id="L323">      w.write(&quot; {\n&quot;);</span>
<span class="nc" id="L324">      Map&lt;String, Object&gt; record = new HashMap&lt;&gt;();</span>
<span class="nc" id="L325">      processClasses(classes, record);</span>
<span class="nc" id="L326">      writeRecord(w, namespace, rootRecordName, record);</span>
<span class="nc" id="L327">      w.write(&quot;}\n&quot;);</span>
<span class="nc" id="L328">    } catch (IOException ex) {</span>
<span class="nc" id="L329">      throw new MojoExecutionException(&quot;Cannot generate config description&quot;, ex);</span>
<span class="nc" id="L330">    }</span>
<span class="nc" id="L331">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>