<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TSDBMeasurementDatabase.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spf4j-core</a> &gt; <a href="index.html" class="el_package">org.spf4j.perf.impl.mdb.tsdb</a> &gt; <span class="el_source">TSDBMeasurementDatabase.java</span></div><h1>TSDBMeasurementDatabase.java</h1><pre class="source lang-java linenums"> /*
 * Copyright (c) 2001, Zoltan Farkas All Rights Reserved.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.spf4j.perf.impl.mdb.tsdb;

import com.google.common.base.Charsets;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.Multimap;
import org.spf4j.base.AbstractRunnable;
import org.spf4j.base.Arrays;
import org.spf4j.base.DefaultScheduler;
import org.spf4j.base.Pair;
import org.spf4j.perf.EntityMeasurementsInfo;
import org.spf4j.perf.MeasurementDatabase;
import org.spf4j.perf.impl.chart.Charts;
import org.spf4j.perf.tsdb.TSTable;
import org.spf4j.perf.tsdb.TimeSeriesDatabase;
import java.awt.image.BufferedImage;
import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import javax.annotation.PreDestroy;
import javax.annotation.concurrent.ThreadSafe;
import javax.imageio.ImageIO;
import javax.management.InstanceAlreadyExistsException;
import javax.management.MBeanRegistrationException;
import javax.management.MalformedObjectNameException;
import javax.management.NotCompliantMBeanException;
import javax.management.ObjectName;
import org.jfree.chart.JFreeChart;
import org.joda.time.DateTimeConstants;
import org.joda.time.LocalDate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 *
 * @author zoly
 */
@ThreadSafe
public final class TSDBMeasurementDatabase
    implements MeasurementDatabase, Closeable, TSDBMeasurementDatabaseMBean {

    private final TimeSeriesDatabase database;
    private volatile ScheduledFuture&lt;?&gt; future;
<span class="fc" id="L69">    private static final Logger LOG = LoggerFactory.getLogger(TSDBMeasurementDatabase.class);</span>

<span class="fc" id="L71">    public TSDBMeasurementDatabase(final String databaseName) throws IOException {</span>
<span class="fc" id="L72">        this.database = new TimeSeriesDatabase(databaseName, new byte[]{});</span>
<span class="fc" id="L73">    }</span>
<span class="fc" id="L74">    private static final AtomicInteger COUNTER = new AtomicInteger(0);</span>

    public void registerJmx() throws MalformedObjectNameException, InstanceAlreadyExistsException,
            MBeanRegistrationException, NotCompliantMBeanException {
<span class="fc" id="L78">        ManagementFactory.getPlatformMBeanServer().registerMBean(this,</span>
                new ObjectName(&quot;SPF4J:name=TSDBMeasurementDatabase&quot; + COUNTER.getAndIncrement()));
<span class="fc" id="L80">    }</span>

    public void closeOnShutdown() {
<span class="nc" id="L83">        Runtime.getRuntime().addShutdownHook(new Thread(new AbstractRunnable(false) {</span>
            @Override
            public void doRun() throws Exception {
<span class="nc" id="L86">                close();</span>
<span class="nc" id="L87">            }</span>
        }, &quot;tsdb shutdown&quot;));
<span class="nc" id="L89">    }</span>

    public void flushEvery(final int intervalMillis) {
<span class="fc" id="L92">        future = DefaultScheduler.INSTANCE.scheduleAtFixedRate(new AbstractRunnable(false) {</span>
            @Override
            public void doRun() throws Exception {
<span class="nc" id="L95">                database.flush();</span>
<span class="nc" id="L96">            }</span>
        }, intervalMillis, intervalMillis, TimeUnit.MILLISECONDS);
<span class="fc" id="L98">    }</span>

    @Override
    public void alocateMeasurements(final EntityMeasurementsInfo measurement,
                                    final int sampleTimeMillis) throws IOException {
<span class="fc" id="L103">        String groupName = measurement.getMeasuredEntity().toString();</span>
<span class="fc" id="L104">        alocateMeasurements(groupName, measurement, sampleTimeMillis);</span>
<span class="fc" id="L105">    }</span>
    
    private void alocateMeasurements(final String groupName, final EntityMeasurementsInfo measurement,
            final int sampleTimeMillis) throws IOException {
<span class="fc" id="L109">        synchronized (database) {</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">            if (!database.hasTSTable(groupName)) {</span>
<span class="fc" id="L111">                String[] measurementNames = measurement.getMeasurementNames();</span>
<span class="fc" id="L112">                byte[] uom = measurement.getUnitOfMeasurement().getBytes(Charsets.UTF_8);</span>
<span class="fc" id="L113">                String [] uoms = measurement.getMeasurementUnits();</span>
<span class="fc" id="L114">                database.addTSTable(groupName, uom, sampleTimeMillis, measurementNames, uoms);</span>
            }
<span class="pc" id="L116">        }</span>
<span class="fc" id="L117">    }</span>


    @Override
    public void saveMeasurements(final EntityMeasurementsInfo measurementInfo,
                    final long[] measurements, final long timeStampMillis, final int sampleTimeMillis)
            throws IOException {
<span class="fc" id="L124">        String groupName = measurementInfo.getMeasuredEntity().toString();</span>
<span class="fc" id="L125">        alocateMeasurements(groupName, measurementInfo, sampleTimeMillis);</span>
<span class="fc" id="L126">        database.write(timeStampMillis, groupName, measurements);</span>
<span class="fc" id="L127">    }</span>

    @PreDestroy
    @Override
    public void close() throws IOException {
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        if (future != null) {</span>
<span class="fc" id="L133">            future.cancel(false);</span>
        }
<span class="fc" id="L135">        database.close();</span>
<span class="fc" id="L136">    }</span>

    private static String fixName(final String name) {
<span class="fc" id="L139">        StringBuilder result = new StringBuilder(name.length());</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">        for (int i = 0; i &lt; name.length(); i++) {</span>
<span class="fc" id="L141">            char c = name.charAt(i);</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">            if (Character.isJavaIdentifierPart(c)) {</span>
<span class="fc" id="L143">                result.append(c);</span>
            }
        }
<span class="fc" id="L146">        return result.toString();</span>
    }

    @Override
    public List&lt;String&gt; generateCharts(final int width, final int height) throws IOException {
<span class="nc" id="L151">        long startTime = ManagementFactory.getRuntimeMXBean().getStartTime();</span>
<span class="nc" id="L152">        long endTime = System.currentTimeMillis();</span>
<span class="nc" id="L153">        return generateCharts(startTime, endTime, width, height);</span>
    }

    /**
     * Quantized recorders will have min, max avg charts and distribution charts
     * generated. Counting recorders will have simple charts generated.
     *
     * @param startTimeMillis
     * @param endTimeMillis
     * @param width
     * @param height
     * @return
     * @throws IOException
     */
    @Override
    public List&lt;String&gt; generateCharts(final long startTimeMillis, final long endTimeMillis,
            final int width, final int height) throws IOException {
        try {
<span class="fc" id="L171">            database.flush();</span>
<span class="fc" id="L172">            List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L173">            Collection&lt;TSTable&gt; columnsInfo = database.getTSTables();</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">            for (TSTable info : columnsInfo) {</span>
<span class="fc" id="L175">                Pair&lt;long[], long[][]&gt; data = database.read(info.getTableName(), startTimeMillis, endTimeMillis);</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">                if (data.getFirst().length &gt; 0) {</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">                    if (canGenerateMinMaxAvgCount(info)) {</span>
<span class="fc" id="L178">                        result.add(generateMinMaxAvgCountChart(info, data, width, height));</span>
                    }
<span class="fc bfc" id="L180" title="All 2 branches covered.">                    if (canGenerateHeatChart(info)) {</span>
<span class="fc" id="L181">                        result.add(generateHeatChart(info, data, width, height));</span>
                    }
                }
<span class="fc" id="L184">            }</span>
<span class="fc" id="L185">            Multimap&lt;String, TSTable&gt; counters = getCounters(columnsInfo);</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">            for (Map.Entry&lt;String, Collection&lt;TSTable&gt;&gt; entry : counters.asMap().entrySet()) {</span>
<span class="fc" id="L187">                long[][] timestamps = new long[entry.getValue().size()][];</span>
<span class="fc" id="L188">                double[][] cdata = new double[entry.getValue().size()][];</span>
<span class="fc" id="L189">                double[][] cdata2 = new double[entry.getValue().size()][];</span>
<span class="fc" id="L190">                int i = 0;</span>
<span class="fc" id="L191">                String[] measurementNames = new String[cdata.length];</span>
<span class="fc" id="L192">                String[] measurementNames2 = new String[cdata2.length];</span>
<span class="fc" id="L193">                String uom1 = &quot;count&quot;;</span>
<span class="fc" id="L194">                String uom2 = &quot;&quot;;</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">                for (TSTable colInfo : entry.getValue()) {</span>
<span class="fc" id="L196">                    Pair&lt;long[], long[][]&gt; data = database.read(colInfo.getTableName(), startTimeMillis, endTimeMillis);</span>
<span class="fc" id="L197">                    timestamps[i] = data.getFirst();</span>
<span class="fc" id="L198">                    cdata[i] = Arrays.getColumnAsDoubles(data.getSecond(), colInfo.getColumnIndex(&quot;count&quot;));</span>
<span class="fc" id="L199">                    cdata2[i] = Arrays.getColumnAsDoubles(data.getSecond(), colInfo.getColumnIndex(&quot;total&quot;));</span>
<span class="fc" id="L200">                    measurementNames[i] = colInfo.getTableName() + &quot;.count&quot;;</span>
<span class="fc" id="L201">                    measurementNames2[i] = colInfo.getTableName() + &quot;.total&quot;;</span>
<span class="fc" id="L202">                    uom2 = new String(colInfo.getTableMetaData(), Charsets.UTF_8);</span>
<span class="fc" id="L203">                    i++;</span>
<span class="fc" id="L204">                }</span>
<span class="fc" id="L205">                result.add(generateCountChart(entry.getKey(), timestamps, measurementNames,</span>
                        measurementNames2, uom1, uom2, cdata, cdata2, width, height));
<span class="fc" id="L207">            }</span>
<span class="fc" id="L208">            LOG.info(&quot;Generated charts {}&quot;, result);</span>
<span class="fc" id="L209">            return result;</span>
<span class="nc" id="L210">        } catch (IOException ex) {</span>
<span class="nc" id="L211">            LOG.error(&quot;Error while generating charts&quot;, ex);</span>
<span class="nc" id="L212">            throw ex;</span>
<span class="nc" id="L213">        } catch (RuntimeException ex) {</span>
<span class="nc" id="L214">            LOG.error(&quot;Error while generating charts&quot;, ex);</span>
<span class="nc" id="L215">            throw ex;</span>
        }
    }

    private static Multimap&lt;String, TSTable&gt; getCounters(final Collection&lt;TSTable&gt; columnInfos) {
<span class="fc" id="L220">        Multimap&lt;String, TSTable&gt; result = HashMultimap.create();</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">        for (TSTable info : columnInfos) {</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">            if (isCounterOnly(info)) {</span>
<span class="fc" id="L223">                String groupName = info.getTableName();</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">                if (groupName.startsWith(&quot;(&quot;)) {</span>
<span class="fc" id="L225">                    int cidx = groupName.indexOf(',');</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">                    if (cidx &gt; 0) {</span>
<span class="fc" id="L227">                        groupName = groupName.substring(1, cidx);</span>
                    }
                }
<span class="fc" id="L230">                result.put(groupName, info);</span>
<span class="fc" id="L231">            }</span>
        }
<span class="fc" id="L233">        return result;</span>
    }

    @edu.umd.cs.findbugs.annotations.SuppressWarnings(&quot;CLI_CONSTANT_LIST_INDEX&quot;)
    public static boolean isCounterOnly(final TSTable info) {
<span class="fc" id="L238">        String[] columns = info.getColumnNames();</span>
<span class="pc bpc" id="L239" title="2 of 6 branches missed.">        return columns.length == 2 &amp;&amp; columns[0].equals(&quot;count&quot;)</span>
                &amp;&amp; columns[1].equals(&quot;total&quot;);
    }

    public static boolean canGenerateMinMaxAvgCount(final TSTable info) {
<span class="pc bpc" id="L244" title="3 of 8 branches missed.">        return ((info.getColumnIndex(&quot;min&quot;) &gt;= 0)</span>
                &amp;&amp; (info.getColumnIndex(&quot;max&quot;) &gt;= 0)
                &amp;&amp; (info.getColumnIndex(&quot;total&quot;) &gt;= 0)
                &amp;&amp; (info.getColumnIndex(&quot;count&quot;) &gt;= 0));
    }

    public static boolean canGenerateCount(final TSTable info) {
<span class="nc bnc" id="L251" title="All 2 branches missed.">        return ((info.getColumnIndex(&quot;count&quot;) &gt;= 0));</span>
    }
    
    
    public static boolean canGenerateHeatChart(final TSTable info) {
<span class="fc bfc" id="L256" title="All 2 branches covered.">        for (String mname : info.getColumnNames()) {</span>
<span class="pc bpc" id="L257" title="1 of 4 branches missed.">            if (mname.startsWith(&quot;Q&quot;) &amp;&amp; mname.contains(&quot;_&quot;)) {</span>
<span class="fc" id="L258">                return true;</span>
            }
        }
<span class="fc" id="L261">        return false;</span>
    }

    private String generateMinMaxAvgCountChart(
            final TSTable info, final Pair&lt;long[], long[][]&gt; data,
            final int width, final int height) throws IOException {
<span class="fc" id="L267">        long[][] vals = data.getSecond();</span>
<span class="fc" id="L268">        double[] min = Arrays.getColumnAsDoubles(vals, info.getColumnIndex(&quot;min&quot;));</span>
<span class="fc" id="L269">        double[] max = Arrays.getColumnAsDoubles(vals, info.getColumnIndex(&quot;max&quot;));</span>
<span class="fc" id="L270">        double[] total = Arrays.getColumnAsDoubles(vals, info.getColumnIndex(&quot;total&quot;));</span>
<span class="fc" id="L271">        double[] count = Arrays.getColumnAsDoubles(vals, info.getColumnIndex(&quot;count&quot;));</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">        for (int i = 0; i &lt; count.length; i++) {</span>
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">            if (count[i] == 0) {</span>
<span class="nc" id="L274">                min[i] = 0;</span>
<span class="nc" id="L275">                max[i] = 0;</span>
            }
        }
<span class="fc" id="L278">        long[] timestamps = data.getFirst();</span>
<span class="fc" id="L279">        BufferedImage combined = Charts.createMinMaxAvgCountImg(&quot;Measurements for &quot;</span>
                + info.getTableName() + &quot; generated by spf4j&quot;,
                timestamps, min, max, total, count, new String(info.getTableMetaData(), Charsets.UTF_8), width, height);
<span class="fc" id="L282">        File dbFile = new File(database.getDBFilePath());</span>
<span class="fc" id="L283">        File graphicFile = File.createTempFile(dbFile.getName() + &quot;_&quot; + fixName(info.getTableName()), &quot;.mmac.png&quot;,</span>
                dbFile.getParentFile());
<span class="fc" id="L285">        ImageIO.write(combined, &quot;png&quot;, graphicFile);</span>
<span class="fc" id="L286">        return graphicFile.getPath();</span>
    }

    private String generateCountChart(
            final String groupName, final long[][] timestamps,
            final String[] measurementNames, final String[] measurementNames2,
            final String uom1, final String uom2,
            final double[][] measurements, final double[][] measurements2,
            final int width, final int height) throws IOException {
<span class="fc" id="L295">        BufferedImage count = Charts.createTimeSeriesJFreeChart(&quot;Measurements for &quot;</span>
                + groupName + &quot; generated by spf4j&quot;,
                timestamps, measurementNames, uom1, measurements).createBufferedImage(width, height / 2);

<span class="fc" id="L299">        BufferedImage total = Charts.createTimeSeriesJFreeChart(null,</span>
                timestamps, measurementNames2, uom2, measurements2).createBufferedImage(width, height / 2);

<span class="fc" id="L302">        BufferedImage combined = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span>
<span class="fc" id="L303">        combined.getGraphics().drawImage(count, 0, 0, null);</span>
<span class="fc" id="L304">        combined.getGraphics().drawImage(total, 0, height / 2, null);</span>


<span class="fc" id="L307">        File dbFile = new File(database.getDBFilePath());</span>
<span class="fc" id="L308">        File graphicFile = File.createTempFile(dbFile.getName() + &quot;_&quot; + fixName(groupName), &quot;.count.png&quot;,</span>
                dbFile.getParentFile());
<span class="fc" id="L310">        ImageIO.write(combined, &quot;png&quot;, graphicFile);</span>
<span class="fc" id="L311">        return graphicFile.getPath();</span>
    }


    private String generateHeatChart(final TSTable info, final Pair&lt;long[], long[][]&gt; data,
            final int width, final int height) throws IOException {
<span class="fc" id="L317">        JFreeChart chart = TimeSeriesDatabase.createHeatJFreeChart(data, info);</span>
<span class="fc" id="L318">        BufferedImage img = chart.createBufferedImage(width, height);</span>
<span class="fc" id="L319">        File dbFile = new File(database.getDBFilePath());</span>
<span class="fc" id="L320">        File graphicFile = File.createTempFile(dbFile.getName() + &quot;_&quot; + fixName(info.getTableName()), &quot;.dist.png&quot;,</span>
                dbFile.getParentFile());
<span class="fc" id="L322">        ImageIO.write(img, &quot;png&quot;, graphicFile);</span>
<span class="fc" id="L323">        return graphicFile.getAbsolutePath();</span>
    }

    @Override
    public List&lt;String&gt; generate(final Properties props) throws IOException {
<span class="nc" id="L328">        int width = Integer.parseInt(props.getProperty(&quot;width&quot;, &quot;1200&quot;));</span>
<span class="nc" id="L329">        int height = Integer.parseInt(props.getProperty(&quot;height&quot;, &quot;800&quot;));</span>
<span class="nc" id="L330">        long startTime = Long.parseLong(props.getProperty(&quot;startTime&quot;,</span>
                Long.toString(new LocalDate().withDayOfWeek(DateTimeConstants.MONDAY).toDate().getTime())));
<span class="nc" id="L332">        long endTime = Long.parseLong(props.getProperty(&quot;endTime&quot;, Long.toString(System.currentTimeMillis())));</span>
<span class="nc" id="L333">        return generateCharts(startTime, endTime, width, height);</span>
    }

    @Override
    public List&lt;String&gt; getParameters() {
<span class="nc" id="L338">        return java.util.Arrays.asList(&quot;width&quot;, &quot;height&quot;, &quot;startTime&quot;, &quot;endTime&quot;);</span>
    }

    @Override
    public void flush() throws IOException {
<span class="nc" id="L343">        database.flush();</span>
<span class="nc" id="L344">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.2.201302030002</span></div></body></html>