<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JVMArguments.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spf4j-core</a> &gt; <a href="index.source.html" class="el_package">org.spf4j.unix</a> &gt; <span class="el_source">JVMArguments.java</span></div><h1>JVMArguments.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2001-2017, Zoltan Farkas All Rights Reserved.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * Additionally licensed with:
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.spf4j.unix;

import com.google.common.io.Files;
import com.sun.jna.StringArray;
import com.sun.jna.Memory;
import com.sun.jna.Native;
import static com.sun.jna.Pointer.NULL;
import com.sun.jna.ptr.IntByReference;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

import java.io.IOException;
import java.io.File;
import java.io.ByteArrayOutputStream;
import java.io.RandomAccessFile;
import java.io.DataInputStream;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import org.spf4j.base.Runtime;
import org.spf4j.unix.CLibrary.FILE;

/**
 * List of arguments for Java VM and application. based on class from akuma lib (http://akuma.kohsuke.org).
 */
@SuppressFBWarnings(&quot;DM_DEFAULT_ENCODING&quot;)
// default char encoding is used on purpose.
public final class JVMArguments {

  private final List&lt;String&gt; arguments;

  public JVMArguments(final int size) {
<span class="fc" id="L66">    this(new ArrayList&lt;&gt;(size));</span>
<span class="fc" id="L67">  }</span>

<span class="fc" id="L69">  public JVMArguments(final Collection&lt;? extends String&gt; c) {</span>
<span class="fc" id="L70">    arguments = new ArrayList&lt;&gt;(c);</span>
<span class="fc" id="L71">  }</span>

  public String getExecutable() {
<span class="fc" id="L74">    return arguments.get(0);</span>
  }

  public String removeSystemProperty(final String pname) {
<span class="nc" id="L78">    String name = &quot;-D&quot; + pname;</span>
<span class="nc" id="L79">    String nameeq = name + '=';</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">    for (Iterator&lt;String&gt; itr = arguments.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L81">      String s = itr.next();</span>
<span class="nc bnc" id="L82" title="All 4 branches missed.">      if (s.equals(name) || s.startsWith(nameeq)) {</span>
<span class="nc" id="L83">        itr.remove();</span>
<span class="nc" id="L84">        return s.substring(nameeq.length());</span>
      }
<span class="nc" id="L86">    }</span>
<span class="nc" id="L87">    return null;</span>
  }

  public int removeAllSystemPropertiesStartingWith(final String pname) {
<span class="fc" id="L91">    String name = &quot;-D&quot; + pname;</span>
<span class="fc" id="L92">    int nrRemoved = 0;</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">    for (Iterator&lt;String&gt; itr = arguments.iterator(); itr.hasNext();) {</span>
<span class="fc" id="L94">      String s = itr.next();</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">      if (s.startsWith(name)) {</span>
<span class="fc" id="L96">        itr.remove();</span>
<span class="fc" id="L97">        nrRemoved++;</span>
      }
<span class="fc" id="L99">    }</span>
<span class="fc" id="L100">    return nrRemoved;</span>
  }

  public void setSystemProperty(final String name, final String value) {
<span class="nc" id="L104">    removeSystemProperty(name);</span>
    // index 0 is the executable name
<span class="nc" id="L106">    arguments.add(1, &quot;-D&quot; + name + '=' + value);</span>
<span class="nc" id="L107">  }</span>

  public void add(final String arg) {
<span class="fc" id="L110">    arguments.add(arg);</span>
<span class="fc" id="L111">  }</span>

  /**
   * Removes the n items from the end. Useful for removing all the Java arguments to rebuild them.
   */
  public void removeTail(final int n) {
<span class="nc" id="L117">    int size = arguments.size();</span>
<span class="nc" id="L118">    arguments.removeAll(arguments.subList(size - n, size));</span>
<span class="nc" id="L119">  }</span>

  public StringArray toStringArray() {
<span class="nc" id="L122">    return new StringArray(arguments.toArray(new String[arguments.size()]));</span>
  }

  /**
   * Gets the process argument list of the current process.
   */
  public static JVMArguments current() throws IOException {
<span class="fc" id="L129">    return of(-1);</span>
  }

  /**
   * Gets the process argument list of the specified process ID.
   *
   * @param pid -1 to indicate the current process.
   */
  public static JVMArguments of(final int pid) throws IOException {
<span class="fc" id="L138">    String os = Runtime.OS_NAME;</span>
<span class="pc bpc" id="L139" title="15 of 18 branches missed.">    switch (os) {</span>
      case &quot;Linux&quot;:
<span class="nc" id="L141">        return ofLinux(pid);</span>
      case &quot;SunOS&quot;:
<span class="nc" id="L143">        return ofSolaris(pid);</span>
      case &quot;Mac OS X&quot;:
<span class="fc" id="L145">        return ofMac(pid);</span>
      case &quot;FreeBSD&quot;:
<span class="nc" id="L147">        return ofFreeBSD(pid);</span>
      default:
<span class="nc" id="L149">        throw new UnsupportedOperationException(&quot;Unsupported Operating System &quot; + os);</span>
    }
  }

  private static JVMArguments ofLinux(final int ppid) throws IOException {
<span class="nc" id="L154">    int pid = resolvePID(ppid);</span>
<span class="nc" id="L155">    String cmdline = Files.asCharSource(new File(&quot;/proc/&quot; + pid + &quot;/cmdline&quot;), Charset.defaultCharset()).read();</span>
<span class="nc" id="L156">    return new JVMArguments(java.util.Arrays.asList(cmdline.split(&quot;\0&quot;)));</span>
  }

  private static int resolvePID(final int pid) {
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">    if (pid == -1) {</span>
<span class="fc" id="L161">      return Runtime.PID;</span>
    } else {
<span class="nc" id="L163">      return pid;</span>
    }
  }

  private static JVMArguments ofSolaris(final int ppid) throws IOException {
    // /proc shows different contents based on the caller's memory model, so we need to know if we are 32 or 64.
    // 32 JVMs are the norm, so err on the 32bit side.
<span class="nc" id="L170">    boolean areWe64 = &quot;64&quot;.equals(System.getProperty(&quot;sun.arch.data.model&quot;));</span>
<span class="nc" id="L171">    int pid = resolvePID(ppid);</span>
<span class="nc" id="L172">    try (RandomAccessFile psinfo = new RandomAccessFile(new File(&quot;/proc/&quot; + pid + &quot;/psinfo&quot;), &quot;r&quot;)) {</span>
      // see http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/sys/procfs.h
      //typedef struct psinfo {
      // int pr_flag; /* process flags */
      // int pr_nlwp; /* number of lwps in the process */
      // pid_t pr_pid; /* process id */
      // pid_t pr_ppid; /* process id of parent */
      // pid_t pr_pgid; /* process id of process group leader */
      // pid_t pr_sid; /* session id */
      // uid_t pr_uid; /* real user id */
      // uid_t pr_euid; /* effective user id */
      // gid_t pr_gid; /* real group id */
      // gid_t pr_egid; /* effective group id */
      // uintptr_t pr_addr; /* address of process */
      // size_t pr_size; /* size of process image in Kbytes */
      // size_t pr_rssize; /* resident set size in Kbytes */
      // dev_t pr_ttydev; /* controlling tty device (or PRNODEV) */
      // ushort_t pr_pctcpu; /* % of recent cpu time used by all lwps */
      // ushort_t pr_pctmem; /* % of system memory used by process */
      // timestruc_t pr_start; /* process start time, from the epoch */
      // timestruc_t pr_time; /* cpu time for this process */
      // timestruc_t pr_ctime; /* cpu time for reaped children */
      // char pr_fname[PRFNSZ]; /* name of exec'ed file */
      // char pr_psargs[PRARGSZ]; /* initial characters of arg list */
      // int pr_wstat; /* if zombie, the wait() status */
      // int pr_argc; /* initial argument count */
      // uintptr_t pr_argv; /* address of initial argument vector */
      // uintptr_t pr_envp; /* address of initial environment vector */
      // char pr_dmodel; /* data model of the process */
      // lwpsinfo_t pr_lwp; /* information for representative lwp */
      //} psinfo_t;

      // see http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/sys/types.h
      // for the size of the various datatype.
      // see http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/cmd/ptools/pargs/pargs.c
      // for how to read this information
<span class="nc" id="L208">      psinfo.seek(8);</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">      if (adjust(psinfo.readInt()) != pid) {</span>
<span class="nc" id="L210">        throw new IOException(&quot;psinfo PID mismatch: &quot; + pid + &quot;, &quot; + psinfo);   // sanity check</span>
      }
      /* The following program computes the offset:
                    #include &lt;stdio.h&gt;
                    #include &lt;sys/procfs.h&gt;
                    int main() {
                      printf(&quot;psinfo_t = %d\n&quot;, sizeof(psinfo_t));
                      psinfo_t *x;
                      x = 0;
                      printf(&quot;%x\n&quot;, &amp;(x-&gt;pr_argc));
                    }
       */

<span class="nc bnc" id="L223" title="All 2 branches missed.">      psinfo.seek(areWe64 ? 0xEC : 0xBC);  // now jump to pr_argc</span>
<span class="nc" id="L224">      int argc = adjust(psinfo.readInt());</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">      long argp = areWe64 ? adjust(psinfo.readLong()) : to64(adjust(psinfo.readInt()));</span>
<span class="nc" id="L226">      File asFile = new File(&quot;/proc/&quot; + pid + &quot;/as&quot;);</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">      if (areWe64) {</span>
        // 32bit and 64bit basically does the same thing, but because the stream position
        // is computed with signed long, doing 64bit seek to a position bigger than Long.MAX_VALUE
        // requres some real hacking. Hence two different code path.
        // (RandomAccessFile uses Java long for offset, so it just can't get to anywhere beyond Long.MAX_VALUE)
<span class="nc" id="L232">        FILE fp = CLibrary.INSTANCE.fopen(asFile.getPath(), &quot;r&quot;);</span>
        try {
<span class="nc" id="L234">          JVMArguments args = new JVMArguments(16);</span>
<span class="nc" id="L235">          Memory m = new Memory(8);</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">          for (int n = 0; n &lt; argc; n++) {</span>
            // read a pointer to one entry
<span class="nc" id="L238">            seek64(fp, argp + ((long) n) * 8);</span>
<span class="nc" id="L239">            m.setLong(0, 0); // just to make sure failed read won't result in bogus value</span>
<span class="nc" id="L240">            CLibrary.INSTANCE.fread(m, 1, 8, fp);</span>
<span class="nc" id="L241">            long p = m.getLong(0);</span>
<span class="nc" id="L242">            args.add(readLine(fp, p));</span>
          }
<span class="nc" id="L244">          return args;</span>
        } finally {
<span class="nc" id="L246">          CLibrary.INSTANCE.fclose(fp);</span>
        }
      } else {
<span class="nc" id="L249">        try (RandomAccessFile as = new RandomAccessFile(asFile, &quot;r&quot;)) {</span>
<span class="nc" id="L250">          JVMArguments args = new JVMArguments(16);</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">          for (int n = 0; n &lt; argc; n++) {</span>
            // read a pointer to one entry
<span class="nc" id="L253">            as.seek(argp + n * 4);</span>
<span class="nc" id="L254">            int p = adjust(as.readInt());</span>

<span class="nc" id="L256">            args.add(readLine(as, p));</span>
          }
<span class="nc" id="L258">          return args;</span>
<span class="nc bnc" id="L259" title="All 8 branches missed.">        }</span>
      }
<span class="nc bnc" id="L261" title="All 12 branches missed.">    }</span>
  }

  /**
   * Seek to the specified position. This method handles offset bigger than {@link Long#MAX_VALUE} correctly.
   *
   * @param upos This value is interpreted as unsigned 64bit integer (even though it's typed 'long')
   */
  private static void seek64(final FILE fp, final long pupos) {
<span class="nc" id="L270">    long upos = pupos;</span>
<span class="nc" id="L271">    CLibrary.INSTANCE.fseek(fp, 0, 0); // start at the beginning</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">    while (upos &lt; 0) {</span>
<span class="nc" id="L273">      long chunk = Long.MAX_VALUE;</span>
<span class="nc" id="L274">      upos -= chunk;</span>
<span class="nc" id="L275">      CLibrary.INSTANCE.fseek(fp, chunk, 1);</span>
<span class="nc" id="L276">    }</span>
<span class="nc" id="L277">    CLibrary.INSTANCE.fseek(fp, upos, 1);</span>
<span class="nc" id="L278">  }</span>

  /**
   * {@link DataInputStream} reads a value in big-endian, so convert it to the correct value on little-endian systems.
   */
  private static int adjust(final int i) {
<span class="nc bnc" id="L284" title="All 2 branches missed.">    if (Runtime.IS_LITTLE_ENDIAN) {</span>
<span class="nc" id="L285">      return (i &lt;&lt; 24) | ((i &lt;&lt; 8) &amp; 0x00FF0000) | ((i &gt;&gt; 8) &amp; 0x0000FF00) | (i &gt;&gt;&gt; 24);</span>
    } else {
<span class="nc" id="L287">      return i;</span>
    }
  }

  private static long adjust(final long i) {
<span class="nc bnc" id="L292" title="All 2 branches missed.">    if (Runtime.IS_LITTLE_ENDIAN) {</span>
<span class="nc" id="L293">      return (i &lt;&lt; 56)</span>
              | ((i &lt;&lt; 40) &amp; 0x00FF000000000000L)
              | ((i &lt;&lt; 24) &amp; 0x0000FF0000000000L)
              | ((i &lt;&lt; 8) &amp; 0x000000FF00000000L)
              | ((i &gt;&gt; 8) &amp; 0x00000000FF000000L)
              | ((i &gt;&gt; 24) &amp; 0x0000000000FF0000L)
              | ((i &gt;&gt; 40) &amp; 0x000000000000FF00L)
              | (i &gt;&gt; 56);
    } else {
<span class="nc" id="L302">      return i;</span>
    }
  }

  /**
   * int to long conversion with zero-padding.
   */
  private static long to64(final int i) {
<span class="nc" id="L310">    return i &amp; 0xFFFFFFFFL;</span>
  }

  private static String readLine(final RandomAccessFile as, final int p) throws IOException {
<span class="nc" id="L314">    as.seek(to64(p));</span>
<span class="nc" id="L315">    ByteArrayOutputStream buf = new ByteArrayOutputStream();</span>
    int ch;
<span class="nc bnc" id="L317" title="All 2 branches missed.">    while ((ch = as.read()) &gt; 0) {</span>
<span class="nc" id="L318">      buf.write(ch);</span>
    }
<span class="nc" id="L320">    return buf.toString();</span>
  }

  private static String readLine(final FILE as, final long p) {
<span class="nc" id="L324">    seek64(as, p);</span>
<span class="nc" id="L325">    Memory m = new Memory(1);</span>
<span class="nc" id="L326">    ByteArrayOutputStream buf = new ByteArrayOutputStream();</span>
    while (true) {
<span class="nc bnc" id="L328" title="All 2 branches missed.">      if (CLibrary.INSTANCE.fread(m, 1, 1, as) == 0) {</span>
<span class="nc" id="L329">        break;</span>
      }
<span class="nc" id="L331">      byte b = m.getByte(0);</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">      if (b == 0) {</span>
<span class="nc" id="L333">        break;</span>
      }
<span class="nc" id="L335">      buf.write(b);</span>
<span class="nc" id="L336">    }</span>
<span class="nc" id="L337">    return buf.toString();</span>
  }

  /**
   * Mac support
   *
   * See http://developer.apple.com/qa/qa2001/qa1123.html http://www.osxfaq.com/man/3/kvm_getprocs.ws
   * http://matburt.net/?p=16 (libkvm is removed from OSX) where is kinfo_proc?
   * http://lists.apple.com/archives/xcode-users/2008/Mar/msg00781.html
   *
   * This code uses sysctl to get the arg/env list:
   * http://www.psychofx.com/psi/trac/browser/psi/trunk/src/arch/macosx/macosx_process.c which came from
   * http://www.opensource.apple.com/darwinsource/10.4.2/top-15/libtop.c
   *
   * sysctl is defined in libc.
   *
   * PS source code for Mac: http://www.opensource.apple.com/darwinsource/10.4.1/adv_cmds-79.1/ps.tproj/
   */
  @SuppressFBWarnings(&quot;PRMC_POSSIBLY_REDUNDANT_METHOD_CALLS&quot;)
  private static JVMArguments ofMac(final int pid) {
    // local constants
<span class="fc" id="L358">    final int ctlKern = 1;</span>
<span class="fc" id="L359">    final int kernArgMax = 8;</span>
<span class="fc" id="L360">    final int kernProcArgs2 = 49;</span>
<span class="fc" id="L361">    final int sizeOfInt = Native.getNativeSize(int.class);</span>
<span class="fc" id="L362">    IntByReference ibf = new IntByReference();</span>

<span class="fc" id="L364">    IntByReference argmaxRef = new IntByReference(0);</span>
<span class="fc" id="L365">    IntByReference size = new IntByReference(sizeOfInt);</span>

    // for some reason, I was never able to get sysctlbyname work.
//        if(LIBC.sysctlbyname(&quot;kern.argmax&quot;, argmaxRef.getPointer(), size, NULL, ibf)!=0)
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">    if (CLibrary.INSTANCE.sysctl(new int[]{ctlKern, kernArgMax}, 2, argmaxRef.getPointer(), size, NULL, ibf) != 0) {</span>
<span class="nc" id="L370">      throw new UnsupportedOperationException(&quot;Failed to get kernl.argmax: &quot;</span>
<span class="nc" id="L371">              + CLibrary.INSTANCE.strerror(Native.getLastError()));</span>
    }

<span class="fc" id="L374">    int argmax = argmaxRef.getValue();</span>
<span class="fc" id="L375">    StringArrayMemory m = new StringArrayMemory(argmax, sizeOfInt);</span>
<span class="fc" id="L376">    size.setValue(argmax);</span>
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">    if (CLibrary.INSTANCE.sysctl(new int[]{ctlKern, kernProcArgs2, resolvePID(pid)}, 3, m, size, NULL, ibf) != 0) {</span>
<span class="nc" id="L378">      throw new UnsupportedOperationException(&quot;Failed to obtain ken.procargs2: &quot;</span>
<span class="nc" id="L379">              + CLibrary.INSTANCE.strerror(Native.getLastError()));</span>
    }
    /*
         * Make a sysctl() call to get the raw argument space of the
         * process.  The layout is documented in start.s, which is part
         * of the Csu project.  In summary, it looks like:
         *
         * /---------------\ 0x00000000
         * :               :
         * :               :
         * |---------------|
         * | argc          |
         * |---------------|
         * | arg[0]        |
         * |---------------|
         * :               :
         * :               :
         * |---------------|
         * | arg[argc - 1] |
         * |---------------|
         * | 0             |
         * |---------------|
         * | env[0]        |
         * |---------------|
         * :               :
         * :               :
         * |---------------|
         * | env[n]        |
         * |---------------|
         * | 0             |
         * |---------------| &lt;-- Beginning of data returned by sysctl()
         * | exec_path     |     is here.
         * |:::::::::::::::|
         * |               |
         * | String area.  |
         * |               |
         * |---------------| &lt;-- Top of stack.
         * :               :
         * :               :
         * \---------------/ 0xffffffff
     */
<span class="fc" id="L420">    int nargs = m.readInt();</span>
<span class="fc" id="L421">    JVMArguments args = new JVMArguments(nargs);</span>
<span class="fc" id="L422">    m.readString(); // exec path</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">    for (int i = 0; i &lt; nargs; i++) {</span>
<span class="fc" id="L424">      m.skip0();</span>
<span class="fc" id="L425">      args.add(m.readString());</span>
    }
<span class="fc" id="L427">    return args;</span>
  }

  @SuppressFBWarnings(&quot;EQ_DOESNT_OVERRIDE_EQUALS&quot;)
  private static final class StringArrayMemory extends Memory {

<span class="fc" id="L433">    private long offset = 0;</span>
    private final int sizeOfInt;

    StringArrayMemory(final long l, final int sizeOfInt) {
<span class="fc" id="L437">      super(l);</span>
<span class="fc" id="L438">      this.sizeOfInt = sizeOfInt;</span>
<span class="fc" id="L439">    }</span>

    int readInt() {
<span class="fc" id="L442">      int r = getInt(offset);</span>
<span class="fc" id="L443">      offset += sizeOfInt;</span>
<span class="fc" id="L444">      return r;</span>
    }

    String readString() {
<span class="fc" id="L448">      ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
      byte ch;
<span class="fc bfc" id="L450" title="All 2 branches covered.">      while ((ch = getByte(offset++)) != '\0') {</span>
<span class="fc" id="L451">        baos.write(ch);</span>
      }
<span class="fc" id="L453">      return baos.toString();</span>
    }

    void skip0() {
      // skip trailing '\0's
<span class="fc bfc" id="L458" title="All 2 branches covered.">      while (getByte(offset) == '\0') {</span>
<span class="fc" id="L459">        offset++;</span>
      }
<span class="fc" id="L461">    }</span>
  }

  private static JVMArguments ofFreeBSD(final int pid) {
    // taken from sys/sysctl.h
<span class="nc" id="L466">    final int ctlKern = 1;</span>
<span class="nc" id="L467">    final int kernArgMax = 8;</span>
<span class="nc" id="L468">    final int kernProc = 14;</span>
<span class="nc" id="L469">    final int kernProcArgs = 7;</span>

<span class="nc" id="L471">    IntByReference ibr = new IntByReference();</span>
<span class="nc" id="L472">    IntByReference sysctlArgMax = new IntByReference();</span>
<span class="nc" id="L473">    IntByReference size = new IntByReference();</span>

<span class="nc" id="L475">    size.setValue(4);</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">    if (CLibrary.INSTANCE.sysctl(new int[]{ctlKern, kernArgMax},</span>
<span class="nc" id="L477">            2, sysctlArgMax.getPointer(), size, NULL, ibr) != 0) {</span>
<span class="nc" id="L478">      throw new UnsupportedOperationException(&quot;Failed to sysctl kern.argmax&quot;);</span>
    }

<span class="nc" id="L481">    int argmax = sysctlArgMax.getValue();</span>
<span class="nc" id="L482">    Memory m = new Memory(argmax);</span>
<span class="nc" id="L483">    size.setValue(argmax);</span>

<span class="nc bnc" id="L485" title="All 2 branches missed.">    if (CLibrary.INSTANCE.sysctl(new int[]{ctlKern, kernProc, kernProcArgs, resolvePID(pid)},</span>
            4, m, size, NULL, ibr) != 0) {
<span class="nc" id="L487">      throw new UnsupportedOperationException();</span>
    }

<span class="nc" id="L490">    ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L491">    ArrayList&lt;String&gt; lArgs = new ArrayList&lt;String&gt;();</span>
    byte ch;
<span class="nc" id="L493">    int offset = 0;</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">    while (offset &lt; size.getValue()) {</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">      while ((ch = m.getByte(offset++)) != '\0') {</span>
<span class="nc" id="L496">        baos.write(ch);</span>
      }
<span class="nc" id="L498">      lArgs.add(baos.toString());</span>
<span class="nc" id="L499">      baos.reset();</span>
    }

<span class="nc" id="L502">    return new JVMArguments(lArgs);</span>
  }

  @Override
  public String toString() {
<span class="fc" id="L507">    return &quot;JVMArguments{&quot; + &quot;arguments=&quot; + arguments + '}';</span>
  }

  @Override
  public int hashCode() {
<span class="nc" id="L512">    return 11 * 7 + Objects.hashCode(this.arguments);</span>
  }

  @Override
  public boolean equals(final Object obj) {
<span class="nc bnc" id="L517" title="All 2 branches missed.">    if (this == obj) {</span>
<span class="nc" id="L518">      return true;</span>
    }
<span class="nc bnc" id="L520" title="All 2 branches missed.">    if (obj == null) {</span>
<span class="nc" id="L521">      return false;</span>
    }
<span class="nc bnc" id="L523" title="All 2 branches missed.">    if (getClass() != obj.getClass()) {</span>
<span class="nc" id="L524">      return false;</span>
    }
<span class="nc" id="L526">    final JVMArguments other = (JVMArguments) obj;</span>
<span class="nc" id="L527">    return Objects.equals(this.arguments, other.arguments);</span>
  }

  public String[] toArray() {
<span class="fc" id="L531">    return arguments.toArray(new String[arguments.size()]);</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>