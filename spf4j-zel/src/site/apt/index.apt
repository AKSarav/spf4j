The Z Expression Language

 Scope: A simple but easy to extend language for doing expression evalutions and calculations in java.
 

 Now there are a few other components out there that do a similar job, here is what it's different (or not :-) ) about this particular implementation:

  1. Implemented using javaCC

  2. Asynchronous programming (function calls can be executed asynchronously or asynchronously)

  3. Expressions are compiled providing decent execution performance. 
     (Outperforms SPEL(Spring) by a few orders of magnitude)

  4. Integer mathematical operations do not overflow.
     Real number representation can be used seamlessly with decimal or binary representation.

  5. Everything is an object, numbers, strings, functions.....

  6. There is only one type of variable:  reference to object,
     you declare a variable by assigning an object to it, all variables are local to the current exec context.
   
  7. ZEL uses the last value out principle, expressions will return the last evaluated expression.
     There is a return keyword that can be used, but it is optional.

  8. Support for deterministic functions, (aka memorization) executions will be cached for deterministic functions

  10. LGPL license

 Here is how you would use the evaluator in your java code:

+-----------------------------------------------------------------------
EX1:    // mathematical expressions 

        Program prog = Program.compile("1+5*4/(1+1)");
        Number result = (Number) prog.execute();

EX2:    // formulas with decimal numbers can be written easer than directly in java
        // decimal numbers are represented with BigDecimal by default in zel
        // regular binary floating point representation can be used as well with "d" suffix.

        BigDecimal result = (BigDecimal) Program.compile("use dec 128; (1.0/3) * 3 + (1 - 1.0/3*3)").execute();

EX3:    // java integration, java objects are supported just like in java:

        Program prog = Program.compile("a.toString().substring(0, 1 + 1)", "a");
        String result = (String) prog.execute(100);

EX4:    // fibonacci recursive definition executes in O(n)
        // deterministic function results are automatically memorized

        String program =
                  "fib = func det (x) { fib(x-1) + fib(x-2) };\n"
                + "fib(0) = 0;"
                + "fib(1) = 1;"
                + "fib(200)"

        Program compiledProgram = Program.compile(program);
        Number result = (Number) compiledProgram.execute();

EX5:    // Async programming.
        // Zel functions are async by default.

        replica = func async (x) {
            sleep random() * 1000;
            out(x, " finished\n");
            return x
        };
        out(first(replica(1), replica(2), replica(3)), " finished first\n");

EX6:    // Explicit ASync function execution.
        // Java method invocation are sync by default
        // using & postfix operator you can call any function async

        private static class TestF {
            public static int f(final int a, final int b) throws InterruptedException {
                Thread.sleep(1000);
                return a + b;
            }
        }
    
        String prog = "f(f(1, 2)&,f(3, 4)&)&";
        Number result = (Number) Program.compile(prog, "f").execute(new JavaMethodCall(TestF.class, "f"));



EX7:    // Async programming, parallel PI
        // functions can be declared to be executed sync or async

        piPart = func (s, x) {
            term = func sync (k) {4 * (-1 ** k) / (2d * k + 1)};
            for i = s; i < x; i++ {
              parts[i] = term(i) 
            };

            for result = 0, i = s; i < x; i++ {
              result = result + parts[i] 
            };
            return result
        };

        pi = func (x, breakup) {
            range = x / breakup;
            l = breakup - 1;
            for i = 0, result = 0, k = 0; i < l; i++ {
              part[i] = piPart(k, k + range);
              k = k + range
            };
            part[i] = piPart(k, x);
            for i = 0, result = 0; i < breakup; i = i + 1 {
               result = result + part[i] 
            };
            return result
        };
        pi(x, 5)


 
+-----------------------------------------------------------------------
  
